<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 2: Processes and File Systems</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <nav class="breadcrumb">
                <a href="../index.html">‚Üê Back to Operating Systems</a>
                <a href="../../index.html" class="home-link">‚Üê Back to Semester 3</a>
                <a href="../../../index.html" class="home-link">üè† All Semesters</a>
            </nav>
            <h1>Unit 2: Processes and File Systems</h1>
            <p class="subtitle">Process Management, CPU Scheduling, and File System Organization</p>
        </header>

        <section id="processes-intro">
            <h2>1. Understanding Processes</h2>
            
            <h3>What is a Process?</h3>
            <p>A <strong>process</strong> is a program in execution. When you double-click on an application icon, the operating system creates a process to run that program. Think of it as bringing a recipe (program) to life by actually cooking the dish (process).</p>

            <div class="example-detailed">
                <h4>Restaurant Kitchen Analogy</h4>
                <p><strong>Program = Recipe Book:</strong> Contains instructions for making a dish</p>
                <p><strong>Process = Actually Cooking:</strong> Chef following recipe to prepare meal</p>
                
                <h5>Key Differences:</h5>
                <ul>
                    <li><strong>Program (Static):</strong> Just instructions stored on disk</li>
                    <li><strong>Process (Dynamic):</strong> Active execution using CPU, memory, and resources</li>
                    <li><strong>Multiple Processes:</strong> Same program can run multiple times (multiple chrome tabs)</li>
                </ul>
            </div>

            <h3>Process in Memory</h3>
            <p>When a process is created, the operating system allocates memory space for it. This memory is organized in a specific structure:</p>

            <div class="visual-diagram">
                <h4>Process Memory Layout</h4>
                <div class="diagram-text">
                    <pre>
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê High Memory Address
        ‚îÇ                                 ‚îÇ
        ‚îÇ          STACK                  ‚îÇ ‚Üê Local variables, function calls
        ‚îÇ    (grows downward)             ‚îÇ   (expands during execution)
        ‚îÇ           ‚Üì                     ‚îÇ
        ‚îÇ                                 ‚îÇ
        ‚îÇ                                 ‚îÇ
        ‚îÇ       FREE SPACE                ‚îÇ ‚Üê Available memory
        ‚îÇ                                 ‚îÇ
        ‚îÇ                                 ‚îÇ
        ‚îÇ           ‚Üë                     ‚îÇ
        ‚îÇ    (grows upward)               ‚îÇ
        ‚îÇ          HEAP                   ‚îÇ ‚Üê Dynamic memory allocation
        ‚îÇ                                 ‚îÇ   (malloc, new objects)
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
        ‚îÇ                                 ‚îÇ
        ‚îÇ          DATA                   ‚îÇ ‚Üê Global variables
        ‚îÇ    (initialized data)           ‚îÇ   Initialized global/static vars
        ‚îÇ                                 ‚îÇ
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
        ‚îÇ                                 ‚îÇ
        ‚îÇ          TEXT                   ‚îÇ ‚Üê Program instructions
        ‚îÇ     (program code)              ‚îÇ   Executable code
        ‚îÇ                                 ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚Üê Low Memory Address
                    </pre>
                </div>
            </div>

            <h3>Process Memory Sections Explained</h3>

            <h4>1. Text Section (Code)</h4>
            <div class="concept">
                <h5>Purpose:</h5>
                <p>Contains the actual program instructions (machine code)</p>
                <h5>Characteristics:</h5>
                <ul>
                    <li><strong>Read-Only:</strong> Program instructions don't change during execution</li>
                    <li><strong>Shared:</strong> Multiple processes can share same text section</li>
                    <li><strong>Fixed Size:</strong> Size determined when program is compiled</li>
                </ul>
                <h5>Example:</h5>
                <p>If you open two calculator programs, they share the same text section (same code) but have separate data sections (different calculations).</p>
            </div>

            <h4>2. Data Section</h4>
            <div class="concept">
                <h5>Purpose:</h5>
                <p>Stores global variables and static data that have initial values</p>
                <h5>Types:</h5>
                <ul>
                    <li><strong>Initialized Data:</strong> Global variables with assigned values</li>
                    <li><strong>Uninitialized Data (BSS):</strong> Global variables without initial values</li>
                </ul>
            </div>

            <h4>3. Heap Section</h4>
            <div class="concept">
                <h5>Purpose:</h5>
                <p>Dynamic memory allocation during program execution</p>
                <h5>Usage:</h5>
                <ul>
                    <li><strong>Runtime Allocation:</strong> Memory requested during program execution</li>
                    <li><strong>Variable Size:</strong> Can grow or shrink as needed</li>
                    <li><strong>Manual Management:</strong> Programmer must allocate and free memory</li>
                </ul>
                <h5>Example:</h5>
                <p>When you load a large image in photo editor, it requests heap memory to store the image data.</p>
            </div>

            <h4>4. Stack Section</h4>
            <div class="concept">
                <h5>Purpose:</h5>
                <p>Stores local variables, function parameters, and return addresses</p>
                <h5>Characteristics:</h5>
                <ul>
                    <li><strong>LIFO Structure:</strong> Last In, First Out (like stack of plates)</li>
                    <li><strong>Automatic Management:</strong> OS manages allocation and deallocation</li>
                    <li><strong>Function Calls:</strong> Each function call adds new frame to stack</li>
                </ul>
            </div>
        </section>

        <section id="process-states">
            <h2>2. Process States and Lifecycle</h2>

            <h3>Process State Model</h3>
            <p>A process goes through different states during its lifecycle, similar to how a person goes through different activities during the day.</p>

            <div class="visual-diagram">
                <h4>Process State Transition Diagram</h4>
                <div class="diagram-text">
                    <pre>
                        NEW (created)
                           ‚îÇ
                           ‚îÇ admit
                           ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄREADY‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ     (waiting for      ‚îÇ
                ‚îÇ      CPU time)        ‚îÇ
                ‚îÇ                       ‚îÇ
     interrupt  ‚îÇ                       ‚îÇ dispatch
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                                        ‚îÇ
        ‚ñº                                        ‚ñº
    WAITING/BLOCKED                           RUNNING
   (waiting for I/O,                     (using CPU)
    resources, events)                        ‚îÇ
        ‚îÇ                                     ‚îÇ
        ‚îÇ I/O completion,                     ‚îÇ exit
        ‚îÇ event occurs                       ‚ñº
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí TERMINATED
                                         (finished)
                    </pre>
                </div>
            </div>

            <h3>Understanding Each Process State</h3>

            <h4>1. NEW State</h4>
            <div class="concept">
                <h5>Definition:</h5>
                <p>Process is being created but not yet ready to execute</p>
                <h5>Activities:</h5>
                <ul>
                    <li><strong>Memory Allocation:</strong> OS assigns memory space for process</li>
                    <li><strong>PCB Creation:</strong> Process Control Block is created</li>
                    <li><strong>Resource Setup:</strong> Initial resources are allocated</li>
                </ul>
                <h5>Real-World Analogy:</h5>
                <p>Like a new employee's first day - paperwork being processed, desk being assigned, but not yet working.</p>
            </div>

            <h4>2. READY State</h4>
            <div class="concept">
                <h5>Definition:</h5>
                <p>Process is prepared to execute but waiting for CPU availability</p>
                <h5>Characteristics:</h5>
                <ul>
                    <li><strong>All Resources Available:</strong> Has everything needed except CPU</li>
                    <li><strong>In Ready Queue:</strong> Waiting in line for processor time</li>
                    <li><strong>Can Be Selected:</strong> Eligible for CPU scheduling</li>
                </ul>
                <h5>Real-World Analogy:</h5>
                <p>Like customers in a bank queue - they're ready to be served, just waiting for the next available teller (CPU).</p>
            </div>

            <h4>3. RUNNING State</h4>
            <div class="concept">
                <h5>Definition:</h5>
                <p>Process is currently using the CPU and executing instructions</p>
                <h5>Important Notes:</h5>
                <ul>
                    <li><strong>Only One Process:</strong> Only one process can run on a CPU core at any time</li>
                    <li><strong>Time Limited:</strong> Gets CPU for a time slice, then may be preempted</li>
                    <li><strong>Active Execution:</strong> Instructions are being fetched and executed</li>
                </ul>
            </div>

            <h4>4. WAITING/BLOCKED State</h4>
            <div class="concept">
                <h5>Definition:</h5>
                <p>Process is waiting for some event to occur (I/O completion, user input, etc.)</p>
                <h5>Common Wait Reasons:</h5>
                <ul>
                    <li><strong>I/O Operations:</strong> Reading from disk, waiting for user input</li>
                    <li><strong>Resource Availability:</strong> Waiting for printer, network connection</li>
                    <li><strong>Process Communication:</strong> Waiting for data from another process</li>
                </ul>
                <h5>Real-World Analogy:</h5>
                <p>Like a chef waiting for ingredients to arrive before continuing to cook.</p>
            </div>

            <h4>5. TERMINATED State</h4>
            <div class="concept">
                <h5>Definition:</h5>
                <p>Process has finished execution and is being cleaned up</p>
                <h5>Cleanup Activities:</h5>
                <ul>
                    <li><strong>Resource Deallocation:</strong> Return memory and other resources</li>
                    <li><strong>PCB Removal:</strong> Delete process control block</li>
                    <li><strong>Exit Status:</strong> Report success or error code</li>
                </ul>
            </div>
        </section>

        <section id="pcb">
            <h2>3. Process Control Block (PCB)</h2>

            <h3>What is a Process Control Block?</h3>
            <p>The PCB is like an employee's personnel file - it contains all important information the operating system needs to manage a process.</p>

            <div class="example-detailed">
                <h4>Employee Record Analogy</h4>
                <p>Just like HR department keeps detailed records for each employee, OS keeps detailed records (PCB) for each process:</p>
                
                <h5>Employee Record Contains:</h5>
                <ul>
                    <li><strong>Employee ID:</strong> Unique identifier</li>
                    <li><strong>Job Description:</strong> What work they do</li>
                    <li><strong>Current Status:</strong> Working, on break, sick leave</li>
                    <li><strong>Resources Assigned:</strong> Office, computer, access cards</li>
                    <li><strong>Performance Data:</strong> Hours worked, projects completed</li>
                </ul>

                <h5>PCB Contains:</h5>
                <ul>
                    <li><strong>Process ID (PID):</strong> Unique process identifier</li>
                    <li><strong>Program Counter:</strong> Next instruction to execute</li>
                    <li><strong>Process State:</strong> NEW, READY, RUNNING, WAITING, TERMINATED</li>
                    <li><strong>CPU Registers:</strong> Current values of processor registers</li>
                    <li><strong>Memory Management:</strong> Memory allocation information</li>
                    <li><strong>I/O Status:</strong> List of open files, devices allocated</li>
                    <li><strong>Accounting Information:</strong> CPU time used, time limits</li>
                </ul>
            </div>

            <h3>PCB Components in Detail</h3>

            <div class="comparison-table">
                <table>
                    <thead>
                        <tr>
                            <th>PCB Component</th>
                            <th>Purpose</th>
                            <th>Example Information</th>
                            <th>Why Important</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Process ID</strong></td>
                            <td>Unique identification</td>
                            <td>PID: 1234</td>
                            <td>OS can distinguish between processes</td>
                        </tr>
                        <tr>
                            <td><strong>Program Counter</strong></td>
                            <td>Track execution progress</td>
                            <td>Address: 0x4000A0</td>
                            <td>Resume execution from correct location</td>
                        </tr>
                        <tr>
                            <td><strong>CPU Registers</strong></td>
                            <td>Save processor state</td>
                            <td>Register values during context switch</td>
                            <td>Restore exact state when process resumes</td>
                        </tr>
                        <tr>
                            <td><strong>Memory Info</strong></td>
                            <td>Track memory usage</td>
                            <td>Base: 1000, Limit: 5000</td>
                            <td>Manage memory allocation and protection</td>
                        </tr>
                        <tr>
                            <td><strong>I/O Status</strong></td>
                            <td>Track open resources</td>
                            <td>Files: doc1.txt, printer: HP_LaserJet</td>
                            <td>Properly release resources when process ends</td>
                        </tr>
                        <tr>
                            <td><strong>Process State</strong></td>
                            <td>Current process status</td>
                            <td>READY, RUNNING, WAITING</td>
                            <td>Scheduler knows how to handle process</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Context Switching</h3>
            <div class="algorithm-steps">
                <h4>What Happens During Context Switch</h4>
                <p>Context switching is like a chef switching between cooking multiple dishes. They must save the current state of one dish before moving to another.</p>
                
                <ol>
                    <li><strong>Save Current Process State</strong>
                        <ul>
                            <li>Store CPU register values in PCB</li>
                            <li>Save program counter location</li>
                            <li>Update process state to READY or WAITING</li>
                        </ul>
                    </li>
                    <li><strong>Select Next Process</strong>
                        <ul>
                            <li>Scheduler chooses next process to run</li>
                            <li>Consider process priority and scheduling algorithm</li>
                        </ul>
                    </li>
                    <li><strong>Load Next Process State</strong>
                        <ul>
                            <li>Restore CPU registers from PCB</li>
                            <li>Set program counter to correct location</li>
                            <li>Update process state to RUNNING</li>
                        </ul>
                    </li>
                    <li><strong>Resume Execution</strong>
                        <ul>
                            <li>Continue executing from where process left off</li>
                            <li>Process doesn't know it was interrupted</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </section>

        <section id="process-scheduling">
            <h2>4. Process Scheduling</h2>

            <h3>Why Do We Need Process Scheduling?</h3>
            <p>In a multitasking environment, multiple processes compete for CPU time. Process scheduling decides which process gets to use the CPU and for how long, ensuring fair and efficient resource utilization.</p>

            <div class="example-detailed">
                <h4>Airport Runway Analogy</h4>
                <p><strong>Problem:</strong> Multiple airplanes (processes) want to use the runway (CPU), but only one can use it at a time.</p>
                
                <h5>Without Scheduling (Chaos):</h5>
                <ul>
                    <li>Planes might crash into each other</li>
                    <li>Some planes wait forever while others use runway repeatedly</li>
                    <li>Emergency flights can't land quickly</li>
                </ul>

                <h5>With Air Traffic Control (Scheduler):</h5>
                <ul>
                    <li><strong>Fair Access:</strong> All planes get their turn</li>
                    <li><strong>Priority Handling:</strong> Emergency flights get priority</li>
                    <li><strong>Efficiency:</strong> Runway used continuously without gaps</li>
                    <li><strong>Safety:</strong> Controlled, organized access</li>
                </ul>
            </div>

            <h3>Types of Schedulers</h3>

            <h4>1. Long-Term Scheduler (Job Scheduler)</h4>
            <div class="concept">
                <h5>Role:</h5>
                <p>Decides which programs should be brought into memory and converted to processes</p>
                <h5>Characteristics:</h5>
                <ul>
                    <li><strong>Less Frequent:</strong> Executes minutes or hours apart</li>
                    <li><strong>Controls Multiprogramming:</strong> Determines how many processes in memory</li>
                    <li><strong>Load Balancing:</strong> Mixes CPU-intensive and I/O-intensive processes</li>
                </ul>
                <h5>Analogy:</h5>
                <p>Like university admissions officer deciding which students get admitted to maintain good balance of different types of students.</p>
            </div>

            <h4>2. Short-Term Scheduler (CPU Scheduler)</h4>
            <div class="concept">
                <h5>Role:</h5>
                <p>Decides which ready process gets CPU next</p>
                <h5>Characteristics:</h5>
                <ul>
                    <li><strong>Very Frequent:</strong> Executes every few milliseconds</li>
                    <li><strong>Fast Decision:</strong> Must be very efficient</li>
                    <li><strong>Direct Impact:</strong> Affects system responsiveness</li>
                </ul>
                <h5>Analogy:</h5>
                <p>Like traffic light controller deciding which direction of traffic gets to move next.</p>
            </div>

            <h4>3. Medium-Term Scheduler (Swapper)</h4>
            <div class="concept">
                <h5>Role:</h5>
                <p>Decides which processes to temporarily remove from memory to disk (swapping)</p>
                <h5>Purpose:</h5>
                <ul>
                    <li><strong>Memory Management:</strong> Free up memory when system is overloaded</li>
                    <li><strong>Performance:</strong> Prevent system from slowing down due to memory shortage</li>
                    <li><strong>Balance:</strong> Control degree of multiprogramming</li>
                </ul>
            </div>
        </section>

        <section id="scheduling-algorithms">
            <h2>5. CPU Scheduling Algorithms</h2>

            <h3>Scheduling Criteria</h3>
            <p>Different scheduling algorithms optimize for different goals. Understanding these criteria helps choose the right algorithm for specific situations.</p>

            <div class="comparison-table">
                <table>
                    <thead>
                        <tr>
                            <th>Criterion</th>
                            <th>Description</th>
                            <th>Goal</th>
                            <th>Important For</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>CPU Utilization</strong></td>
                            <td>Percentage of time CPU is busy</td>
                            <td>Maximize</td>
                            <td>System efficiency</td>
                        </tr>
                        <tr>
                            <td><strong>Throughput</strong></td>
                            <td>Number of processes completed per unit time</td>
                            <td>Maximize</td>
                            <td>Overall productivity</td>
                        </tr>
                        <tr>
                            <td><strong>Turnaround Time</strong></td>
                            <td>Time from submission to completion</td>
                            <td>Minimize</td>
                            <td>User satisfaction</td>
                        </tr>
                        <tr>
                            <td><strong>Waiting Time</strong></td>
                            <td>Time spent waiting in ready queue</td>
                            <td>Minimize</td>
                            <td>Process efficiency</td>
                        </tr>
                        <tr>
                            <td><strong>Response Time</strong></td>
                            <td>Time from request to first response</td>
                            <td>Minimize</td>
                            <td>Interactive systems</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Common Scheduling Algorithms</h3>

            <h4>1. First Come First Served (FCFS)</h4>
            <div class="algorithm-steps">
                <h5>How FCFS Works:</h5>
                <p><strong>Simple Rule:</strong> Process that arrives first gets served first, like a queue at grocery store.</p>
                
                <h5>Algorithm Steps:</h5>
                <ol>
                    <li>Maintain queue of ready processes</li>
                    <li>When CPU becomes free, give it to process at front of queue</li>
                    <li>Process runs until completion (non-preemptive)</li>
                    <li>Next process in queue gets CPU</li>
                </ol>

                <h5>Example Scenario:</h5>
                <p><strong>Processes:</strong> P1 (24ms), P2 (3ms), P3 (3ms) arrive in this order</p>
                <p><strong>Execution Order:</strong> P1 ‚Üí P2 ‚Üí P3</p>
                <p><strong>Waiting Times:</strong> P1: 0ms, P2: 24ms, P3: 27ms</p>
                <p><strong>Average Waiting Time:</strong> (0 + 24 + 27) √∑ 3 = 17ms</p>
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <h4>‚úÖ FCFS Advantages</h4>
                    <ul>
                        <li><strong>Simple:</strong> Easy to understand and implement</li>
                        <li><strong>Fair:</strong> No process is indefinitely postponed</li>
                        <li><strong>No Starvation:</strong> Every process eventually gets executed</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>‚ö†Ô∏è FCFS Disadvantages</h4>
                    <ul>
                        <li><strong>Convoy Effect:</strong> Short processes wait for long ones</li>
                        <li><strong>Poor Response Time:</strong> Interactive users may wait long</li>
                        <li><strong>Inefficient:</strong> CPU may be idle during I/O operations</li>
                    </ul>
                </div>
            </div>

            <h4>2. Shortest Job First (SJF)</h4>
            <div class="algorithm-steps">
                <h5>How SJF Works:</h5>
                <p><strong>Smart Rule:</strong> Always execute the process with the shortest execution time first.</p>

                <h5>Algorithm Steps:</h5>
                <ol>
                    <li>Examine all ready processes</li>
                    <li>Select process with minimum execution time</li>
                    <li>Execute selected process to completion</li>
                    <li>Repeat for remaining processes</li>
                </ol>

                <h5>Example Comparison:</h5>
                <p><strong>Same Processes:</strong> P1 (24ms), P2 (3ms), P3 (3ms)</p>
                <p><strong>SJF Order:</strong> P2 ‚Üí P3 ‚Üí P1</p>
                <p><strong>Waiting Times:</strong> P1: 6ms, P2: 0ms, P3: 3ms</p>
                <p><strong>Average Waiting Time:</strong> (6 + 0 + 3) √∑ 3 = 3ms (much better than FCFS!)</p>
            </div>

            <h4>3. Round Robin (RR)</h4>
            <div class="algorithm-steps">
                <h5>How Round Robin Works:</h5>
                <p><strong>Fair Rule:</strong> Each process gets equal time slices in circular order.</p>

                <h5>Key Concept - Time Quantum:</h5>
                <ul>
                    <li><strong>Time Quantum:</strong> Fixed time slice (e.g., 20ms) each process gets</li>
                    <li><strong>Preemptive:</strong> Process is interrupted when time slice expires</li>
                    <li><strong>Circular Queue:</strong> Processes rotate in circular fashion</li>
                </ul>

                <h5>Playground Analogy:</h5>
                <p>Like children taking turns on a swing - each child gets exactly 5 minutes, then must give turn to next child in line.</p>

                <h5>Algorithm Steps:</h5>
                <ol>
                    <li>Set time quantum (e.g., 20ms)</li>
                    <li>Give CPU to first process in ready queue</li>
                    <li>If process finishes within time quantum, move to next process</li>
                    <li>If time quantum expires, preempt process and move to back of queue</li>
                    <li>Repeat until all processes complete</li>
                </ol>
            </div>

            <h4>4. Priority Scheduling</h4>
            <div class="concept">
                <h5>How Priority Scheduling Works:</h5>
                <p>Each process is assigned a priority number. CPU is always allocated to the process with highest priority.</p>

                <h5>Priority Assignment Examples:</h5>
                <ul>
                    <li><strong>System Processes:</strong> Highest priority (OS maintenance)</li>
                    <li><strong>Interactive Processes:</strong> High priority (user interface responsiveness)</li>
                    <li><strong>Background Processes:</strong> Lower priority (file indexing, backups)</li>
                </ul>

                <h5>Hospital Emergency Room Analogy:</h5>
                <ul>
                    <li><strong>Critical Patients:</strong> Highest priority (heart attack)</li>
                    <li><strong>Urgent Cases:</strong> High priority (broken bone)</li>
                    <li><strong>Routine Checkups:</strong> Normal priority</li>
                    <li><strong>Rule:</strong> More critical cases are treated first, regardless of arrival time</li>
                </ul>

                <h5>Problem - Priority Inversion & Starvation:</h5>
                <p><strong>Starvation:</strong> Low-priority processes may never execute if high-priority processes keep arriving</p>
                <p><strong>Solution - Aging:</strong> Gradually increase priority of waiting processes over time</p>
            </div>
        </section>

        <section id="inter-process-communication">
            <h2>6. Inter-Process Communication (IPC)</h2>

            <h3>Why Do Processes Need to Communicate?</h3>
            <p>Sometimes processes need to work together to accomplish complex tasks. They need secure ways to share information and coordinate their activities.</p>

            <div class="example-detailed">
                <h4>Team Project Analogy</h4>
                <p>Imagine a group project where team members work on different parts:</p>
                
                <h5>Communication Needs:</h5>
                <ul>
                    <li><strong>Share Progress:</strong> "I finished the introduction"</li>
                    <li><strong>Pass Data:</strong> "Here's the research data you need"</li>
                    <li><strong>Coordinate:</strong> "Wait for me to finish before you start"</li>
                    <li><strong>Synchronize:</strong> "Let's all meet at 3 PM to review"</li>
                </ul>
            </div>

            <h3>IPC Mechanisms</h3>

            <h4>1. Shared Memory</h4>
            <div class="concept">
                <h5>How It Works:</h5>
                <p>Processes share a common memory area where they can read and write data</p>
                
                <h5>Whiteboard Analogy:</h5>
                <p>Like team members using a shared whiteboard - anyone can write information and others can read it</p>

                <h5>Advantages:</h5>
                <ul>
                    <li><strong>Fast:</strong> Direct memory access, no OS intervention</li>
                    <li><strong>Efficient:</strong> No copying data between processes</li>
                </ul>

                <h5>Challenges:</h5>
                <ul>
                    <li><strong>Synchronization:</strong> Must coordinate access to prevent conflicts</li>
                    <li><strong>Protection:</strong> Processes can accidentally interfere with each other</li>
                </ul>
            </div>

            <h4>2. Message Passing</h4>
            <div class="concept">
                <h5>How It Works:</h5>
                <p>Processes send messages to each other through the operating system</p>

                <h5>Email Analogy:</h5>
                <p>Like sending emails - you write message, send through email system (OS), recipient receives in inbox</p>

                <h5>Types:</h5>
                <ul>
                    <li><strong>Direct Communication:</strong> Send message directly to specific process</li>
                    <li><strong>Indirect Communication:</strong> Send to mailbox/queue, recipient checks mailbox</li>
                </ul>

                <h5>Advantages:</h5>
                <ul>
                    <li><strong>Safe:</strong> OS handles all coordination and protection</li>
                    <li><strong>Flexible:</strong> Works across network and different machines</li>
                </ul>

                <h5>Disadvantages:</h5>
                <ul>
                    <li><strong>Slower:</strong> OS involvement adds overhead</li>
                    <li><strong>Limited Size:</strong> Messages typically have size limits</li>
                </ul>
            </div>

            <h4>3. Pipes</h4>
            <div class="example-detailed">
                <h4>Understanding Pipes</h4>
                <p>Pipes are like physical pipes that connect two processes, allowing data to flow from one to another.</p>

                <h5>Types of Pipes:</h5>
                <h4>Anonymous Pipes (Ordinary Pipes)</h4>
                <ul>
                    <li><strong>Parent-Child Only:</strong> Only related processes can communicate</li>
                    <li><strong>Unidirectional:</strong> Data flows in one direction only</li>
                    <li><strong>Example:</strong> command1 | command2 (output of command1 becomes input to command2)</li>
                </ul>

                <h4>Named Pipes (FIFOs)</h4>
                <ul>
                    <li><strong>Any Processes:</strong> Unrelated processes can communicate</li>
                    <li><strong>File-like Interface:</strong> Appears as special file in file system</li>
                    <li><strong>Persistent:</strong> Exists until explicitly deleted</li>
                </ul>

                <h5>Water Pipe Analogy:</h5>
                <p>Like connecting two houses with a water pipe - one house can send water (data) and the other receives it.</p>
            </div>
        </section>

        <section id="multithreading">
            <h2>7. Multithreading Models</h2>

            <h3>What are Threads?</h3>
            <p>A <strong>thread</strong> is a lightweight process - a smaller unit of execution within a process. If a process is like a company, threads are like employees within that company.</p>

            <div class="example-detailed">
                <h4>Restaurant Kitchen Analogy</h4>
                <p><strong>Process = Restaurant Kitchen:</strong> The entire kitchen operation</p>
                <p><strong>Threads = Kitchen Staff:</strong> Different workers (chef, prep cook, dishwasher) within same kitchen</p>

                <h5>Benefits of Multiple Workers (Threads):</h5>
                <ul>
                    <li><strong>Parallel Work:</strong> Chef cooks while prep cook chops vegetables</li>
                    <li><strong>Shared Resources:</strong> All workers use same equipment and ingredients</li>
                    <li><strong>Coordination:</strong> Workers communicate and coordinate tasks</li>
                    <li><strong>Efficiency:</strong> More dishes prepared in same time</li>
                </ul>

                <h5>Thread Advantages in Computing:</h5>
                <ul>
                    <li><strong>Responsiveness:</strong> UI thread keeps interface responsive while background thread processes data</li>
                    <li><strong>Resource Sharing:</strong> Threads share memory, files, and other process resources</li>
                    <li><strong>Economy:</strong> Creating threads is faster and uses less memory than creating new processes</li>
                    <li><strong>Scalability:</strong> Can utilize multiple CPU cores effectively</li>
                </ul>
            </div>

            <h3>Multithreading Models</h3>

            <h4>1. Many-to-One Model</h4>
            <div class="concept">
                <h5>Structure:</h5>
                <p>Many user-level threads mapped to one kernel thread</p>

                <h5>How It Works:</h5>
                <ul>
                    <li><strong>User-Level Threads:</strong> Managed by application, not OS</li>
                    <li><strong>Single Kernel Thread:</strong> OS sees only one thread per process</li>
                    <li><strong>Thread Library:</strong> Application manages thread switching</li>
                </ul>

                <h5>Classroom Analogy:</h5>
                <p>Like a classroom where students work in groups, but teacher (OS) only sees the classroom as one unit.</p>

                <h5>Pros and Cons:</h5>
                <ul>
                    <li><strong>‚úÖ Fast Thread Operations:</strong> No OS involvement in thread management</li>
                    <li><strong>‚ö†Ô∏è No True Parallelism:</strong> Cannot use multiple CPU cores</li>
                    <li><strong>‚ö†Ô∏è Blocking Issues:</strong> If one thread blocks, entire process blocks</li>
                </ul>
            </div>

            <h4>2. One-to-One Model</h4>
            <div class="concept">
                <h5>Structure:</h5>
                <p>Each user thread mapped to one kernel thread</p>

                <h5>How It Works:</h5>
                <ul>
                    <li><strong>Kernel Threads:</strong> OS directly manages each thread</li>
                    <li><strong>True Parallelism:</strong> Different threads can run on different CPU cores</li>
                    <li><strong>Independent Scheduling:</strong> Each thread scheduled independently</li>
                </ul>

                <h5>Individual Contractor Analogy:</h5>
                <p>Like hiring individual contractors for a project - each contractor (thread) is managed directly by project manager (OS).</p>

                <h5>Pros and Cons:</h5>
                <ul>
                    <li><strong>‚úÖ True Concurrency:</strong> Multiple threads can run simultaneously</li>
                    <li><strong>‚úÖ Better Blocking:</strong> One thread blocking doesn't affect others</li>
                    <li><strong>‚ö†Ô∏è Higher Overhead:</strong> More system resources needed</li>
                    <li><strong>‚ö†Ô∏è Limited Threads:</strong> System may limit number of threads</li>
                </ul>
            </div>

            <h4>3. Many-to-Many Model</h4>
            <div class="concept">
                <h5>Structure:</h5>
                <p>Many user threads multiplexed to smaller or equal number of kernel threads</p>

                <h5>How It Works:</h5>
                <ul>
                    <li><strong>Flexible Mapping:</strong> OS can adjust kernel threads based on need</li>
                    <li><strong>Hybrid Approach:</strong> Combines benefits of both previous models</li>
                    <li><strong>Dynamic Allocation:</strong> Kernel threads created/destroyed as needed</li>
                </ul>

                <h5>Taxi Service Analogy:</h5>
                <p>Like a taxi company with many customers (user threads) but fewer taxis (kernel threads). Company optimally assigns taxis based on demand.</p>
            </div>

            <h3>Thrashing</h3>
            <div class="concept">
                <h5>What is Thrashing?</h5>
                <p>Thrashing occurs when system spends more time managing memory (swapping pages) than executing actual programs.</p>

                <h5>Busy Restaurant Kitchen Analogy:</h5>
                <p>Kitchen becomes so busy that chefs spend more time looking for ingredients and tools than actually cooking. Result: no food gets prepared despite lots of activity.</p>

                <h5>Causes of Thrashing:</h5>
                <ul>
                    <li><strong>Too Many Processes:</strong> More processes than available memory</li>
                    <li><strong>Poor Scheduling:</strong> Processes frequently request memory not currently loaded</li>
                    <li><strong>Inadequate Memory:</strong> System doesn't have enough physical memory</li>
                </ul>

                <h5>Solutions:</h5>
                <ul>
                    <li><strong>Reduce Multiprogramming:</strong> Run fewer processes simultaneously</li>
                    <li><strong>Add Memory:</strong> Increase physical memory</li>
                    <li><strong>Better Algorithms:</strong> Improve page replacement strategies</li>
                </ul>
            </div>
        </section>

        <section id="file-systems">
            <h2>8. File Systems</h2>

            <h3>What is a File System?</h3>
            <p>A file system is like the organizational system for a library - it determines how files are stored, organized, and retrieved on storage devices.</p>

            <div class="concept">
                <h4>File System Responsibilities:</h4>
                <ul>
                    <li><strong>Storage Organization:</strong> How files are physically stored on disk</li>
                    <li><strong>Naming:</strong> How files are identified and named</li>
                    <li><strong>Access Methods:</strong> How programs can read/write file data</li>
                    <li><strong>Protection:</strong> Who can access which files</li>
                    <li><strong>Reliability:</strong> Protecting data from loss or corruption</li>
                </ul>
            </div>

            <h3>Types of Files</h3>

            <h4>1. Regular Files (Data Files)</h4>
            <div class="concept">
                <h5>Purpose:</h5>
                <p>Store user data and information</p>
                <h5>Types:</h5>
                <ul>
                    <li><strong>Text Files:</strong> Human-readable text (.txt, .html, .csv)</li>
                    <li><strong>Binary Files:</strong> Machine-readable data (.exe, .jpg, .mp3)</li>
                    <li><strong>Database Files:</strong> Structured data storage</li>
                    <li><strong>Multimedia Files:</strong> Images, videos, audio</li>
                </ul>
            </div>

            <h4>2. Directory Files</h4>
            <div class="concept">
                <h5>Purpose:</h5>
                <p>Contain information about other files and subdirectories</p>
                <h5>Function:</h5>
                <ul>
                    <li><strong>Organization:</strong> Group related files together</li>
                    <li><strong>Navigation:</strong> Provide hierarchical structure</li>
                    <li><strong>Metadata Storage:</strong> Store file attributes and properties</li>
                </ul>
            </div>

            <h4>3. Special Files</h4>
            <div class="concept">
                <h5>Device Files:</h5>
                <p>Represent hardware devices as files (Unix/Linux concept)</p>
                <h5>Examples:</h5>
                <ul>
                    <li><strong>/dev/disk0:</strong> Hard disk</li>
                    <li><strong>/dev/printer:</strong> Printer device</li>
                    <li><strong>/dev/null:</strong> Special file that discards all data</li>
                </ul>
            </div>

            <h3>File Access Methods</h3>

            <h4>1. Sequential Access</h4>
            <div class="example-detailed">
                <h5>How Sequential Access Works:</h5>
                <p>Data is read/written in order from beginning to end, like reading a book page by page.</p>

                <h5>Cassette Tape Analogy:</h5>
                <ul>
                    <li><strong>Linear Access:</strong> Must go through previous songs to reach desired song</li>
                    <li><strong>No Skipping:</strong> Cannot directly jump to middle</li>
                    <li><strong>Simple:</strong> Easy to implement and understand</li>
                </ul>

                <h5>Best For:</h5>
                <ul>
                    <li><strong>Log Files:</strong> Adding new entries at end</li>
                    <li><strong>Backup Operations:</strong> Processing all data in order</li>
                    <li><strong>Streaming:</strong> Video/audio playback</li>
                </ul>
            </div>

            <h4>2. Random Access (Direct Access)</h4>
            <div class="example-detailed">
                <h5>How Random Access Works:</h5>
                <p>Can jump directly to any part of file without reading previous parts</p>

                <h5>CD/DVD Analogy:</h5>
                <ul>
                    <li><strong>Direct Jump:</strong> Can skip directly to any track</li>
                    <li><strong>Address-Based:</strong> Specify exact location to read/write</li>
                    <li><strong>Fast Access:</strong> No need to scan through unwanted data</li>
                </ul>

                <h5>Best For:</h5>
                <ul>
                    <li><strong>Database Files:</strong> Finding specific records quickly</li>
                    <li><strong>Virtual Memory:</strong> Loading specific pages on demand</li>
                    <li><strong>Large Files:</strong> Editing specific sections without loading entire file</li>
                </ul>
            </div>

            <h4>3. Indexed Access</h4>
            <div class="concept">
                <h5>How Indexed Access Works:</h5>
                <p>Uses an index (like book's table of contents) to quickly locate data</p>

                <h5>Library Card Catalog Analogy:</h5>
                <ul>
                    <li><strong>Index Cards:</strong> Point to location of actual books</li>
                    <li><strong>Quick Lookup:</strong> Find book location without searching entire library</li>
                    <li><strong>Multiple Indexes:</strong> Search by author, title, subject</li>
                </ul>

                <h5>Advantages:</h5>
                <ul>
                    <li><strong>Fast Search:</strong> Quickly locate data without full scan</li>
                    <li><strong>Flexible Queries:</strong> Support different search criteria</li>
                </ul>
            </div>

            <h3>File Allocation Methods</h3>

            <h4>1. Contiguous Allocation</h4>
            <div class="algorithm-steps">
                <h5>How Contiguous Allocation Works:</h5>
                <p>Each file occupies a set of contiguous blocks on disk, like reserving consecutive seats in a theater.</p>

                <h5>Process:</h5>
                <ol>
                    <li><strong>File Creation:</strong> Request specific number of consecutive blocks</li>
                    <li><strong>Directory Entry:</strong> Store starting block and file length</li>
                    <li><strong>File Access:</strong> Calculate block addresses using start + offset</li>
                </ol>

                <h5>Parking Lot Analogy:</h5>
                <p>Like parking a long truck - need multiple consecutive parking spaces. Easy to find the truck later (know exact location), but hard to find enough consecutive spaces in busy lot.</p>
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <h4>‚úÖ Contiguous Advantages</h4>
                    <ul>
                        <li><strong>Simple:</strong> Easy to implement and calculate addresses</li>
                        <li><strong>Fast Access:</strong> Excellent performance for sequential access</li>
                        <li><strong>Minimal Overhead:</strong> Only need starting address and length</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>‚ö†Ô∏è Contiguous Disadvantages</h4>
                    <ul>
                        <li><strong>External Fragmentation:</strong> Hard to find large contiguous space</li>
                        <li><strong>File Size Issues:</strong> Difficult to expand files</li>
                        <li><strong>Waste:</strong> Must allocate worst-case size upfront</li>
                    </ul>
                </div>
            </div>

            <h4>2. Linked Allocation</h4>
            <div class="algorithm-steps">
                <h5>How Linked Allocation Works:</h5>
                <p>File blocks are linked together like a chain, where each block points to the next block.</p>

                <h5>Process:</h5>
                <ol>
                    <li><strong>File Creation:</strong> Allocate first block</li>
                    <li><strong>Block Linking:</strong> Each block contains pointer to next block</li>
                    <li><strong>Directory Entry:</strong> Store pointer to first block</li>
                    <li><strong>File Access:</strong> Follow chain of pointers to read file</li>
                </ol>

                <h5>Treasure Hunt Analogy:</h5>
                <p>Like a treasure hunt where each clue leads to next location. Start at first clue (directory entry), follow chain until you find all treasure (file data).</p>
            </div>

            <h4>3. Indexed Allocation</h4>
            <div class="concept">
                <h5>How Indexed Allocation Works:</h5>
                <p>Each file has an index block that contains pointers to all blocks belonging to that file</p>

                <h5>Phone Directory Analogy:</h5>
                <ul>
                    <li><strong>Phone Book = Index Block:</strong> Contains addresses (pointers) of all contacts</li>
                    <li><strong>Contacts = File Blocks:</strong> Actual data stored at different locations</li>
                    <li><strong>Quick Access:</strong> Look up any contact directly from phone book</li>
                </ul>

                <h5>Advantages:</h5>
                <ul>
                    <li><strong>Direct Access:</strong> Can jump to any part of file quickly</li>
                    <li><strong>No External Fragmentation:</strong> Blocks can be anywhere on disk</li>
                    <li><strong>Dynamic Size:</strong> Files can grow easily</li>
                </ul>

                <h5>Disadvantages:</h5>
                <ul>
                    <li><strong>Index Overhead:</strong> Need space for index blocks</li>
                    <li><strong>Small File Waste:</strong> Small files still need full index block</li>
                </ul>
            </div>

            <h3>Directory Structure</h3>

            <h4>1. Single-Level Directory</h4>
            <div class="concept">
                <h5>Structure:</h5>
                <p>All files in one directory - no subdirectories</p>
                <h5>Simple Desktop Analogy:</h5>
                <p>Like having all documents scattered on your desk - everything visible but hard to organize</p>
                <h5>Problems:</h5>
                <ul>
                    <li><strong>Naming Conflicts:</strong> Cannot have files with same name</li>
                    <li><strong>Hard to Organize:</strong> No grouping of related files</li>
                    <li><strong>Scalability:</strong> Becomes unmanageable with many files</li>
                </ul>
            </div>

            <h4>2. Two-Level Directory</h4>
            <div class="concept">
                <h5>Structure:</h5>
                <p>Separate directory for each user</p>
                <h5>Office Building Analogy:</h5>
                <p>Like office building where each person has their own office (directory) - no conflicts between people's files</p>
                <h5>Benefits:</h5>
                <ul>
                    <li><strong>User Isolation:</strong> Each user has private file space</li>
                    <li><strong>Same Names OK:</strong> Different users can have files with same name</li>
                </ul>
                <h5>Limitations:</h5>
                <ul>
                    <li><strong>No Subdirectories:</strong> Cannot organize files within user directory</li>
                    <li><strong>No Sharing:</strong> Difficult for users to share files</li>
                </ul>
            </div>

            <h4>3. Hierarchical (Tree) Directory</h4>
            <div class="example-detailed">
                <h4>Modern Directory Structure</h4>
                <p>Most modern operating systems use hierarchical directory structure, like organizing files in folders within folders.</p>

                <h5>File Cabinet Analogy:</h5>
                <ul>
                    <li><strong>Filing Cabinet = Root Directory:</strong> Main container</li>
                    <li><strong>Drawers = Main Folders:</strong> Documents, Pictures, Programs</li>
                    <li><strong>Folders within Drawers = Subdirectories:</strong> 2024_Taxes, Vacation_Photos</li>
                    <li><strong>Documents = Files:</strong> Individual documents within folders</li>
                </ul>

                <h5>Path Examples:</h5>
                <ul>
                    <li><strong>Absolute Path:</strong> /Users/John/Documents/Projects/Report.docx</li>
                    <li><strong>Relative Path:</strong> ../Pictures/vacation.jpg (relative to current location)</li>
                </ul>

                <h5>Advantages:</h5>
                <ul>
                    <li><strong>Natural Organization:</strong> Groups related files logically</li>
                    <li><strong>Scalable:</strong> Can handle millions of files efficiently</li>
                    <li><strong>Security:</strong> Can set permissions at directory level</li>
                    <li><strong>Navigation:</strong> Easy to browse and search</li>
                </ul>
            </div>
        </section>

        <footer>
            <div class="summary-box">
                <h3>üéØ Unit 2 Summary: Processes and File Systems</h3>
                <div class="summary-table">
                    <table>
                        <tr>
                            <th>Topic</th>
                            <th>Key Concept</th>
                            <th>Remember This</th>
                        </tr>
                        <tr>
                            <td>Processes</td>
                            <td>Programs in execution with memory layout</td>
                            <td>Process = active program using resources</td>
                        </tr>
                        <tr>
                            <td>Process States</td>
                            <td>NEW ‚Üí READY ‚Üí RUNNING ‚Üí WAITING/TERMINATED</td>
                            <td>Processes transition through lifecycle states</td>
                        </tr>
                        <tr>
                            <td>PCB</td>
                            <td>Process Control Block stores all process info</td>
                            <td>Like employee record for each process</td>
                        </tr>
                        <tr>
                            <td>CPU Scheduling</td>
                            <td>FCFS, SJF, Round Robin, Priority scheduling</td>
                            <td>Different algorithms optimize for different goals</td>
                        </tr>
                        <tr>
                            <td>IPC</td>
                            <td>Shared memory, message passing, pipes</td>
                            <td>Processes communicate for cooperation</td>
                        </tr>
                        <tr>
                            <td>Multithreading</td>
                            <td>Many-to-One, One-to-One, Many-to-Many models</td>
                            <td>Threads enable parallel execution within process</td>
                        </tr>
                        <tr>
                            <td>File Systems</td>
                            <td>Contiguous, Linked, Indexed allocation</td>
                            <td>Different methods for storing files on disk</td>
                        </tr>
                        <tr>
                            <td>Directory Structure</td>
                            <td>Single-level, Two-level, Hierarchical</td>
                            <td>Evolution from simple to organized structure</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="checklist">
                <h4>‚úÖ Unit 2 Learning Objectives Achieved:</h4>
                <ul>
                    <li>Understand process concept, memory layout, and lifecycle</li>
                    <li>Know process states and transitions</li>
                    <li>Comprehend Process Control Block (PCB) structure and purpose</li>
                    <li>Master CPU scheduling algorithms and their trade-offs</li>
                    <li>Learn inter-process communication mechanisms</li>
                    <li>Understand multithreading models and thrashing</li>
                    <li>Know file types and access methods</li>
                    <li>Understand file allocation methods and directory structures</li>
                </ul>
            </div>

            <div class="exam-tips">
                <h4>üìù 15-Mark Question Strategy for Unit 2</h4>
                <ul>
                    <li><strong>Process Questions:</strong> Draw state diagrams + explain transitions with examples</li>
                    <li><strong>Scheduling Algorithm Questions:</strong> Work through numerical examples step-by-step</li>
                    <li><strong>IPC Questions:</strong> Compare mechanisms with advantages/disadvantages</li>
                    <li><strong>File System Questions:</strong> Draw allocation structures + explain with examples</li>
                    <li><strong>Always Show:</strong> Calculations, diagrams, real-world applications</li>
                </ul>
            </div>
        </div>
    </footer>
</div>
</body>
</html>