<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 1: Finite Automata and Regular Expressions</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <nav class="breadcrumb">
                <a href="../index.html">‚Üê Back to Theory of Computation</a>
                <a href="../../index.html" class="home-link">‚Üê Back to Semester 3</a>
                <a href="../../../index.html" class="home-link">üè† All Semesters</a>
            </nav>
            <h1>Unit 1: Finite Automata and Regular Expressions</h1>
            <p class="subtitle">Building Your First Computational Models</p>
        </header>

        <main>
            <section id="finite-state-systems">
                <h2>1. Finite State Systems - The Foundation of Computation</h2>
                
                <h3>Understanding State Machines Through Real-World Examples</h3>
                <p>A <strong>Finite State System</strong> is like a simple robot that can be in different "states" and can change from one state to another based on inputs it receives. Think of it as a machine with a limited memory that can only remember which state it's currently in.</p>
                
                <div class="example-detailed">
                    <h4>üö¶ Traffic Light System - Your First State Machine</h4>
                    
                    <h5>The System:</h5>
                    <p>A traffic light has three states: Red, Yellow, and Green. It changes states based on a timer (input).</p>
                    
                    <h5>States and Transitions:</h5>
                    <ul>
                        <li><strong>State 1: Red</strong> ‚Üí Timer expires ‚Üí Go to Green</li>
                        <li><strong>State 2: Green</strong> ‚Üí Timer expires ‚Üí Go to Yellow</li>
                        <li><strong>State 3: Yellow</strong> ‚Üí Timer expires ‚Üí Go to Red</li>
                    </ul>

                    <div class="state-diagram">
                        Red ‚Üí Green ‚Üí Yellow ‚Üí Red ‚Üí Green ‚Üí ...
                        <br><br>
                        Input: Timer Signal
                        <br>
                        States: {Red, Green, Yellow}
                        <br>
                        Start State: Red
                    </div>

                    <h5>Key Insights:</h5>
                    <ul>
                        <li><strong>Finite States:</strong> Only 3 possible states (not infinite)</li>
                        <li><strong>Deterministic:</strong> From each state, there's exactly one next state for each input</li>
                        <li><strong>Memory:</strong> The system only "remembers" its current state</li>
                        <li><strong>Input-Driven:</strong> State changes happen based on inputs</li>
                    </ul>
                </div>

                <div class="example-detailed">
                    <h4>üîê Password Validation System</h4>
                    
                    <h5>The Problem:</h5>
                    <p>Create a system that accepts passwords with exactly the pattern: "pass" followed by any number of digits.</p>
                    
                    <h5>Valid Passwords:</h5>
                    <ul>
                        <li>"pass1" ‚úì</li>
                        <li>"pass123" ‚úì</li>
                        <li>"pass0000" ‚úì</li>
                    </ul>

                    <h5>Invalid Passwords:</h5>
                    <ul>
                        <li>"password" ‚úó (extra letters after digits)</li>
                        <li>"pas1" ‚úó (incomplete "pass")</li>
                        <li>"pass" ‚úó (no digits)</li>
                    </ul>

                    <h5>State Machine Design:</h5>
                    <div class="state-diagram">
                        q0 --p--> q1 --a--> q2 --s--> q3 --s--> q4 --digit--> q5
                        <br>
                        q5 --digit--> q5 (loop for more digits)
                        <br><br>
                        States: q0(start), q1, q2, q3, q4, q5(accept)
                        <br>
                        Alphabet: {p, a, s, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
                        <br>
                        Accept State: q5 (password is valid)
                    </div>
                </div>

                <h3>Basic Definitions and Components</h3>
                <div class="definition-box">
                    <h4>üìù Formal Definition of Finite Automaton</h4>
                    
                    <p>A <strong>Finite Automaton</strong> is a 5-tuple (Q, Œ£, Œ¥, q‚ÇÄ, F) where:</p>
                    
                    <ul>
                        <li><strong>Q:</strong> Finite set of states</li>
                        <li><strong>Œ£:</strong> Finite input alphabet</li>
                        <li><strong>Œ¥:</strong> Transition function Œ¥: Q √ó Œ£ ‚Üí Q</li>
                        <li><strong>q‚ÇÄ:</strong> Start state (q‚ÇÄ ‚àà Q)</li>
                        <li><strong>F:</strong> Set of accept states (F ‚äÜ Q)</li>
                    </ul>

                    <h5>What Each Component Means:</h5>
                    <ul>
                        <li><strong>States (Q):</strong> All possible conditions the machine can be in</li>
                        <li><strong>Alphabet (Œ£):</strong> All possible input symbols the machine can read</li>
                        <li><strong>Transitions (Œ¥):</strong> Rules for moving from one state to another</li>
                        <li><strong>Start State (q‚ÇÄ):</strong> Where the machine begins processing</li>
                        <li><strong>Accept States (F):</strong> States that indicate successful processing</li>
                    </ul>
                </div>
            </section>

            <section id="dfa">
                <h2>2. Deterministic Finite Automata (DFA) - Predictable Machines</h2>
                
                <h3>Understanding Deterministic Behavior</h3>
                <div class="concept">
                    <h4>üéØ What Makes an Automaton "Deterministic"?</h4>
                    
                    <p>A <strong>Deterministic Finite Automaton (DFA)</strong> is like a well-programmed robot that always knows exactly what to do next. Given its current state and the next input symbol, there is exactly one state it will move to - no ambiguity, no choices.</p>
                    
                    <h5>Key Properties of DFAs:</h5>
                    <ul>
                        <li><strong>Unique Transitions:</strong> From each state, each input leads to exactly one next state</li>
                        <li><strong>Complete Function:</strong> Every state has a transition for every input symbol</li>
                        <li><strong>Predictable:</strong> Given the same input sequence, always produces the same result</li>
                        <li><strong>No Memory:</strong> Only remembers the current state, not the history</li>
                    </ul>
                </div>

                <h3>Building Your First DFA - Even Number of 1s</h3>
                <div class="algorithm-steps">
                    <h4>üîß Step-by-Step DFA Construction</h4>
                    
                    <h5>Problem:</h5>
                    <p>Design a DFA that accepts binary strings containing an even number of 1s.</p>
                    
                    <h5>Examples:</h5>
                    <ul>
                        <li>"" (empty string) ‚úì (0 is even)</li>
                        <li>"0" ‚úì (zero 1s)</li>
                        <li>"11" ‚úì (two 1s)</li>
                        <li>"101" ‚úó (three 1s)</li>
                        <li>"1001" ‚úì (two 1s)</li>
                    </ul>

                    <h5>Step 1: Identify What to Track</h5>
                    <p>We need to track whether we've seen an even or odd number of 1s so far.</p>
                    
                    <h5>Step 2: Design States</h5>
                    <ul>
                        <li><strong>q‚ÇÄ (Even):</strong> Seen even number of 1s (including 0)</li>
                        <li><strong>q‚ÇÅ (Odd):</strong> Seen odd number of 1s</li>
                    </ul>

                    <h5>Step 3: Define Transitions</h5>
                    <div class="state-diagram">
                        From q‚ÇÄ (Even):
                        <br>
                        - Read '0': Stay in q‚ÇÄ (count unchanged)
                        <br>
                        - Read '1': Go to q‚ÇÅ (even ‚Üí odd)
                        <br><br>
                        From q‚ÇÅ (Odd):
                        <br>
                        - Read '0': Stay in q‚ÇÅ (count unchanged)
                        <br>
                        - Read '1': Go to q‚ÇÄ (odd ‚Üí even)
                    </div>

                    <h5>Step 4: Complete DFA Definition</h5>
                    <ul>
                        <li><strong>Q = {q‚ÇÄ, q‚ÇÅ}</strong></li>
                        <li><strong>Œ£ = {0, 1}</strong></li>
                        <li><strong>Start State = q‚ÇÄ</strong></li>
                        <li><strong>Accept States = {q‚ÇÄ}</strong></li>
                        <li><strong>Transition Function Œ¥:</strong>
                            <ul>
                                <li>Œ¥(q‚ÇÄ, 0) = q‚ÇÄ</li>
                                <li>Œ¥(q‚ÇÄ, 1) = q‚ÇÅ</li>
                                <li>Œ¥(q‚ÇÅ, 0) = q‚ÇÅ</li>
                                <li>Œ¥(q‚ÇÅ, 1) = q‚ÇÄ</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <h3>Testing Your DFA - Trace Through Examples</h3>
                <div class="example-detailed">
                    <h4>üß™ Tracing String "1101"</h4>
                    
                    <div class="algorithm-steps">
                        <ol>
                            <li><strong>Start:</strong> State q‚ÇÄ, String "1101"</li>
                            <li><strong>Read '1':</strong> Œ¥(q‚ÇÄ, 1) = q‚ÇÅ, Remaining "101"</li>
                            <li><strong>Read '1':</strong> Œ¥(q‚ÇÅ, 1) = q‚ÇÄ, Remaining "01"</li>
                            <li><strong>Read '0':</strong> Œ¥(q‚ÇÄ, 0) = q‚ÇÄ, Remaining "1"</li>
                            <li><strong>Read '1':</strong> Œ¥(q‚ÇÄ, 1) = q‚ÇÅ, Remaining ""</li>
                            <li><strong>End:</strong> State q‚ÇÅ (not accepting)</li>
                            <li><strong>Result:</strong> String "1101" is REJECTED ‚úó</li>
                        </ol>
                    </div>

                    <p><strong>Verification:</strong> "1101" has three 1s, which is odd, so rejection is correct!</p>
                </div>

                <div class="example-detailed">
                    <h4>üß™ Tracing String "1100"</h4>
                    
                    <div class="algorithm-steps">
                        <ol>
                            <li><strong>Start:</strong> State q‚ÇÄ, String "1100"</li>
                            <li><strong>Read '1':</strong> Œ¥(q‚ÇÄ, 1) = q‚ÇÅ, Remaining "100"</li>
                            <li><strong>Read '1':</strong> Œ¥(q‚ÇÅ, 1) = q‚ÇÄ, Remaining "00"</li>
                            <li><strong>Read '0':</strong> Œ¥(q‚ÇÄ, 0) = q‚ÇÄ, Remaining "0"</li>
                            <li><strong>Read '0':</strong> Œ¥(q‚ÇÄ, 0) = q‚ÇÄ, Remaining ""</li>
                            <li><strong>End:</strong> State q‚ÇÄ (accepting)</li>
                            <li><strong>Result:</strong> String "1100" is ACCEPTED ‚úì</li>
                        </ol>
                    </div>

                    <p><strong>Verification:</strong> "1100" has two 1s, which is even, so acceptance is correct!</p>
                </div>
            </section>

            <section id="ndfa">
                <h2>3. Non-Deterministic Finite Automata (NDFA) - Machines with Choices</h2>
                
                <h3>Understanding Non-Determinism</h3>
                <div class="concept">
                    <h4>üé≤ What Makes an Automaton "Non-Deterministic"?</h4>
                    
                    <p>A <strong>Non-Deterministic Finite Automaton (NDFA)</strong> is like a machine that can make choices. When it reads an input symbol, it might have multiple possible next states to choose from, or sometimes no valid transition at all.</p>
                    
                    <h5>Key Differences from DFA:</h5>
                    <ul>
                        <li><strong>Multiple Transitions:</strong> From one state, the same input can lead to multiple states</li>
                        <li><strong>Missing Transitions:</strong> Some state-input combinations might have no transition</li>
                        <li><strong>Parallel Computation:</strong> Conceptually explores all possible paths simultaneously</li>
                        <li><strong>Acceptance:</strong> Accepts if ANY possible path leads to an accept state</li>
                    </ul>
                </div>

                <h3>NDFA Example - Strings Ending with "01"</h3>
                <div class="algorithm-steps">
                    <h4>üîß Building an NDFA</h4>
                    
                    <h5>Problem:</h5>
                    <p>Design an NDFA that accepts binary strings ending with "01".</p>
                    
                    <h5>Examples:</h5>
                    <ul>
                        <li>"01" ‚úì</li>
                        <li>"101" ‚úì</li>
                        <li>"1001" ‚úì</li>
                        <li>"110101" ‚úì</li>
                        <li>"10" ‚úó</li>
                        <li>"011" ‚úó</li>
                    </ul>

                    <h5>NDFA Design Strategy:</h5>
                    <p>The key insight: We don't know when the final "01" pattern starts, so we need to "guess" when we see a '0' that might be the start of the ending "01".</p>
                    
                    <h5>States:</h5>
                    <ul>
                        <li><strong>q‚ÇÄ:</strong> Start state, haven't seen the beginning of "01" yet</li>
                        <li><strong>q‚ÇÅ:</strong> Just read '0', might be start of final "01"</li>
                        <li><strong>q‚ÇÇ:</strong> Just completed "01" pattern (accept state)</li>
                    </ul>

                    <h5>Transitions:</h5>
                    <div class="state-diagram">
                        From q‚ÇÄ:
                        <br>
                        - Read '0': Go to q‚ÇÄ (stay) AND q‚ÇÅ (guess this starts "01")
                        <br>
                        - Read '1': Go to q‚ÇÄ (stay)
                        <br><br>
                        From q‚ÇÅ:
                        <br>
                        - Read '1': Go to q‚ÇÇ (complete "01" pattern)
                        <br>
                        - Read '0': No transition (this path dies)
                        <br><br>
                        From q‚ÇÇ:
                        <br>
                        - Read '0': Go to q‚ÇÅ (new "01" might start)
                        <br>
                        - Read '1': No transition (string doesn't end with "01")
                    </div>
                </div>

                <h3>Tracing NDFA Execution - Multiple Paths</h3>
                <div class="example-detailed">
                    <h4>üß™ Tracing String "1001" in NDFA</h4>
                    
                    <div class="algorithm-steps">
                        <h5>Initial:</h5>
                        <p>Current states: {q‚ÇÄ}, Remaining string: "1001"</p>
                        
                        <h5>Read '1':</h5>
                        <ul>
                            <li>From q‚ÇÄ on '1': Go to q‚ÇÄ</li>
                            <li>Current states: {q‚ÇÄ}, Remaining: "001"</li>
                        </ul>

                        <h5>Read '0':</h5>
                        <ul>
                            <li>From q‚ÇÄ on '0': Go to q‚ÇÄ AND q‚ÇÅ</li>
                            <li>Current states: {q‚ÇÄ, q‚ÇÅ}, Remaining: "01"</li>
                        </ul>

                        <h5>Read '0':</h5>
                        <ul>
                            <li>From q‚ÇÄ on '0': Go to q‚ÇÄ AND q‚ÇÅ</li>
                            <li>From q‚ÇÅ on '0': No transition (this path dies)</li>
                            <li>Current states: {q‚ÇÄ, q‚ÇÅ}, Remaining: "1"</li>
                        </ul>

                        <h5>Read '1':</h5>
                        <ul>
                            <li>From q‚ÇÄ on '1': Go to q‚ÇÄ</li>
                            <li>From q‚ÇÅ on '1': Go to q‚ÇÇ</li>
                            <li>Current states: {q‚ÇÄ, q‚ÇÇ}, Remaining: ""</li>
                        </ul>

                        <h5>Result:</h5>
                        <p>Final states include q‚ÇÇ (accept state) ‚Üí String "1001" is ACCEPTED ‚úì</p>
                    </div>
                </div>

                <div class="important-note">
                    <h4>üéØ Key NDFA Insight</h4>
                    <p>An NDFA accepts a string if there exists at least one computational path that leads to an accept state. It doesn't matter if other paths fail - as long as one path succeeds, the string is accepted.</p>
                </div>
            </section>

            <section id="equivalence">
                <h2>4. Equivalence of DFA and NDFA - Same Power, Different Style</h2>
                
                <h3>The Fundamental Equivalence Theorem</h3>
                <div class="concept">
                    <h4>‚öñÔ∏è DFA vs NDFA: Equal Computational Power</h4>
                    
                    <p><strong>Theorem:</strong> For every NDFA, there exists an equivalent DFA that accepts exactly the same language.</p>
                    
                    <p>This means that non-determinism doesn't give us more computational power - it just gives us a more convenient way to design automata for certain problems.</p>
                    
                    <h5>Why This Matters:</h5>
                    <ul>
                        <li><strong>Design Flexibility:</strong> Use NDFA when it's easier to design</li>
                        <li><strong>Implementation Reality:</strong> Convert to DFA for actual computer implementation</li>
                        <li><strong>Theoretical Understanding:</strong> Both models recognize the same class of languages (regular languages)</li>
                    </ul>
                </div>

                <h3>Subset Construction Algorithm - Converting NDFA to DFA</h3>
                <div class="algorithm-steps">
                    <h4>üîÑ The Conversion Process</h4>
                    
                    <h5>Key Idea:</h5>
                    <p>Each state in the new DFA represents a <em>set of states</em> that the NDFA could be in simultaneously.</p>
                    
                    <h5>Algorithm Steps:</h5>
                    <ol>
                        <li><strong>Start State:</strong> Create DFA start state = {NDFA start state}</li>
                        <li><strong>For each DFA state (set of NDFA states):</strong>
                            <ul>
                                <li>For each input symbol</li>
                                <li>Find all NDFA states reachable from any state in the current set</li>
                                <li>Create new DFA state for this set (if not already created)</li>
                                <li>Add transition to this new state</li>
                            </ul>
                        </li>
                        <li><strong>Accept States:</strong> DFA state is accepting if it contains any NDFA accept state</li>
                        <li><strong>Repeat:</strong> Until no new DFA states are created</li>
                    </ol>
                </div>

                <div class="example-detailed">
                    <h4>üîß Example: Converting "Ends with 01" NDFA to DFA</h4>
                    
                    <h5>Original NDFA States:</h5>
                    <ul>
                        <li>q‚ÇÄ: Start state</li>
                        <li>q‚ÇÅ: Seen '0', might be start of "01"</li>
                        <li>q‚ÇÇ: Accept state (completed "01")</li>
                    </ul>

                    <h5>Conversion Process:</h5>
                    <div class="algorithm-steps">
                        <h6>Step 1: DFA Start State</h6>
                        <p>DFA_q‚ÇÄ = {q‚ÇÄ}</p>

                        <h6>Step 2: Transitions from DFA_q‚ÇÄ</h6>
                        <ul>
                            <li>On '0': NDFA q‚ÇÄ goes to {q‚ÇÄ, q‚ÇÅ} ‚Üí Create DFA_q‚ÇÅ = {q‚ÇÄ, q‚ÇÅ}</li>
                            <li>On '1': NDFA q‚ÇÄ goes to {q‚ÇÄ} ‚Üí Stay in DFA_q‚ÇÄ</li>
                        </ul>

                        <h6>Step 3: Transitions from DFA_q‚ÇÅ = {q‚ÇÄ, q‚ÇÅ}</h6>
                        <ul>
                            <li>On '0': From q‚ÇÄ‚Üí{q‚ÇÄ,q‚ÇÅ}, From q‚ÇÅ‚Üí‚àÖ ‚Üí Result: {q‚ÇÄ, q‚ÇÅ} = DFA_q‚ÇÅ</li>
                            <li>On '1': From q‚ÇÄ‚Üí{q‚ÇÄ}, From q‚ÇÅ‚Üí{q‚ÇÇ} ‚Üí Create DFA_q‚ÇÇ = {q‚ÇÄ, q‚ÇÇ}</li>
                        </ul>

                        <h6>Step 4: Transitions from DFA_q‚ÇÇ = {q‚ÇÄ, q‚ÇÇ}</h6>
                        <ul>
                            <li>On '0': From q‚ÇÄ‚Üí{q‚ÇÄ,q‚ÇÅ}, From q‚ÇÇ‚Üí{q‚ÇÅ} ‚Üí Result: {q‚ÇÄ, q‚ÇÅ} = DFA_q‚ÇÅ</li>
                            <li>On '1': From q‚ÇÄ‚Üí{q‚ÇÄ}, From q‚ÇÇ‚Üí‚àÖ ‚Üí Result: {q‚ÇÄ} = DFA_q‚ÇÄ</li>
                        </ul>
                    </div>

                    <h5>Final DFA:</h5>
                    <ul>
                        <li><strong>States:</strong> {DFA_q‚ÇÄ, DFA_q‚ÇÅ, DFA_q‚ÇÇ}</li>
                        <li><strong>Start State:</strong> DFA_q‚ÇÄ</li>
                        <li><strong>Accept States:</strong> {DFA_q‚ÇÇ} (contains NDFA accept state q‚ÇÇ)</li>
                        <li><strong>Transitions:</strong> Complete and deterministic</li>
                    </ul>
                </div>
            </section>

            <section id="epsilon-moves">
                <h2>5. Finite Automata with Œµ-moves - Silent Transitions</h2>
                
                <h3>Understanding Epsilon Transitions</h3>
                <div class="concept">
                    <h4>üëª Silent Moves in Automata</h4>
                    
                    <p><strong>Epsilon (Œµ) transitions</strong> are "silent" moves that an automaton can make without reading any input symbol. Think of them as "free" transitions that happen spontaneously.</p>
                    
                    <h5>Key Properties of Œµ-moves:</h5>
                    <ul>
                        <li><strong>No Input Consumed:</strong> Machine moves to new state without reading a symbol</li>
                        <li><strong>Non-deterministic:</strong> Can choose when to take Œµ-transitions</li>
                        <li><strong>Closure:</strong> From any state, can reach all states connected by Œµ-transitions</li>
                        <li><strong>Convenience:</strong> Makes some automata designs much simpler</li>
                    </ul>
                </div>

                <h3>Œµ-Closure and Extended Transitions</h3>
                <div class="mathematical-foundation">
                    <h4>üîÑ Computing Œµ-Closure</h4>
                    
                    <h5>Œµ-Closure Definition:</h5>
                    <p>The <strong>Œµ-closure</strong> of a state q is the set of all states reachable from q using only Œµ-transitions (including q itself).</p>
                    
                    <h5>Algorithm for Œµ-Closure:</h5>
                    <ol>
                        <li>Start with the state itself: Œµ-closure(q) = {q}</li>
                        <li>Add all states reachable by one Œµ-transition</li>
                        <li>Recursively add states reachable from newly added states</li>
                        <li>Continue until no new states are added</li>
                    </ol>

                    <h5>Extended Transition Function:</h5>
                    <p>Œ¥ÃÇ(q, w) = set of all states reachable from q by reading string w (including Œµ-moves)</p>
                </div>

                <div class="example-detailed">
                    <h4>üîß Example: Automaton with Œµ-moves</h4>
                    
                    <h5>Problem:</h5>
                    <p>Design an automaton that accepts strings that are either all 0s or all 1s.</p>
                    
                    <h5>Solution with Œµ-moves:</h5>
                    <div class="state-diagram">
                        q‚ÇÄ --Œµ--> q‚ÇÅ (branch to "all 0s" path)
                        <br>
                        q‚ÇÄ --Œµ--> q‚ÇÇ (branch to "all 1s" path)
                        <br>
                        q‚ÇÅ --0--> q‚ÇÅ (loop on 0s)
                        <br>
                        q‚ÇÇ --1--> q‚ÇÇ (loop on 1s)
                        <br><br>
                        Accept states: {q‚ÇÅ, q‚ÇÇ}
                    </div>

                    <h5>Œµ-Closures:</h5>
                    <ul>
                        <li>Œµ-closure(q‚ÇÄ) = {q‚ÇÄ, q‚ÇÅ, q‚ÇÇ}</li>
                        <li>Œµ-closure(q‚ÇÅ) = {q‚ÇÅ}</li>
                        <li>Œµ-closure(q‚ÇÇ) = {q‚ÇÇ}</li>
                    </ul>

                    <h5>String Processing "000":</h5>
                    <ol>
                        <li>Start: Œµ-closure({q‚ÇÄ}) = {q‚ÇÄ, q‚ÇÅ, q‚ÇÇ}</li>
                        <li>Read '0': From q‚ÇÅ go to q‚ÇÅ, others have no transition ‚Üí {q‚ÇÅ}</li>
                        <li>Read '0': From q‚ÇÅ go to q‚ÇÅ ‚Üí {q‚ÇÅ}</li>
                        <li>Read '0': From q‚ÇÅ go to q‚ÇÅ ‚Üí {q‚ÇÅ}</li>
                        <li>Result: q‚ÇÅ is accept state ‚Üí ACCEPTED ‚úì</li>
                    </ol>
                </div>

                <h3>Eliminating Œµ-moves</h3>
                <div class="algorithm-steps">
                    <h4>üîÑ Converting Œµ-NFA to NFA</h4>
                    
                    <p>Any automaton with Œµ-moves can be converted to an equivalent automaton without Œµ-moves.</p>
                    
                    <h5>Conversion Algorithm:</h5>
                    <ol>
                        <li><strong>Compute Œµ-closures:</strong> For every state, find all states reachable via Œµ-moves</li>
                        <li><strong>New transitions:</strong> If state p can reach state q via Œµ-moves, and q has transition on symbol a to r, then add transition from p on a to r</li>
                        <li><strong>New accept states:</strong> If a state can reach an accept state via Œµ-moves, make it an accept state</li>
                        <li><strong>Remove Œµ-transitions:</strong> Delete all Œµ-transitions from the automaton</li>
                    </ol>
                </div>
            </section>

            <section id="regular-expressions">
                <h2>6. Regular Expressions - Pattern Matching Language</h2>
                
                <h3>Understanding Regular Expressions</h3>
                <div class="concept">
                    <h4>üîç The Language of Patterns</h4>
                    
                    <p><strong>Regular Expressions</strong> are a concise way to describe patterns in strings. They're like a mathematical shorthand for describing the same languages that finite automata can recognize.</p>
                    
                    <h5>Why Regular Expressions Matter:</h5>
                    <ul>
                        <li><strong>Practical:</strong> Used in text editors, programming languages, databases</li>
                        <li><strong>Concise:</strong> Describe complex patterns in short expressions</li>
                        <li><strong>Equivalent:</strong> Express exactly the same languages as finite automata</li>
                        <li><strong>Intuitive:</strong> Often easier to write than drawing automata</li>
                    </ul>
                </div>

                <h3>Regular Expression Syntax and Operations</h3>
                <div class="definition-box">
                    <h4>üìù Basic Regular Expression Operations</h4>
                    
                    <h5>Atomic Expressions:</h5>
                    <ul>
                        <li><strong>‚àÖ:</strong> Empty language (matches nothing)</li>
                        <li><strong>Œµ:</strong> Empty string (matches only the empty string)</li>
                        <li><strong>a:</strong> Single symbol (matches only the string "a")</li>
                    </ul>

                    <h5>Compound Operations:</h5>
                    <ul>
                        <li><strong>Union (R‚ÇÅ + R‚ÇÇ):</strong> Matches strings that match either R‚ÇÅ or R‚ÇÇ</li>
                        <li><strong>Concatenation (R‚ÇÅR‚ÇÇ):</strong> Matches strings that are R‚ÇÅ followed by R‚ÇÇ</li>
                        <li><strong>Kleene Star (R*):</strong> Matches zero or more repetitions of R</li>
                    </ul>

                    <h5>Operator Precedence (highest to lowest):</h5>
                    <ol>
                        <li>Kleene Star (*)</li>
                        <li>Concatenation</li>
                        <li>Union (+)</li>
                    </ol>
                </div>

                <h3>Building Regular Expressions - Examples</h3>
                <div class="example-detailed">
                    <h4>üîß Regular Expression Construction Examples</h4>
                    
                    <h5>Example 1: Binary strings with even number of 1s</h5>
                    <ul>
                        <li><strong>Pattern:</strong> Any number of 0s, with pairs of 1s scattered throughout</li>
                        <li><strong>Strategy:</strong> 0s can appear anywhere, 1s must appear in pairs</li>
                        <li><strong>Regular Expression:</strong> (0 + 11)*</li>
                        <li><strong>Explanation:</strong> Any combination of 0s and pairs of 1s</li>
                    </ul>

                    <h5>Example 2: Strings ending with "01"</h5>
                    <ul>
                        <li><strong>Pattern:</strong> Any string followed by "01"</li>
                        <li><strong>Strategy:</strong> (any symbols)* followed by 01</li>
                        <li><strong>Regular Expression:</strong> (0 + 1)*01</li>
                        <li><strong>Explanation:</strong> Any sequence of 0s and 1s, ending with 01</li>
                    </ul>

                    <h5>Example 3: Strings containing "101" as substring</h5>
                    <ul>
                        <li><strong>Pattern:</strong> (prefix)(101)(suffix)</li>
                        <li><strong>Strategy:</strong> Any string + "101" + any string</li>
                        <li><strong>Regular Expression:</strong> (0 + 1)*101(0 + 1)*</li>
                        <li><strong>Explanation:</strong> "101" appears somewhere in the string</li>
                    </ul>

                    <h5>Example 4: Valid identifiers (programming)</h5>
                    <ul>
                        <li><strong>Pattern:</strong> Letter followed by letters/digits</li>
                        <li><strong>Strategy:</strong> (letter)(letter + digit)*</li>
                        <li><strong>Regular Expression:</strong> (a+b+...+z)(a+b+...+z+0+1+...+9)*</li>
                        <li><strong>Explanation:</strong> Starts with letter, continues with letters or digits</li>
                    </ul>
                </div>

                <h3>Regular Expression to Automaton Conversion</h3>
                <div class="algorithm-steps">
                    <h4>üîÑ Thompson's Construction Algorithm</h4>
                    
                    <p>Any regular expression can be converted to an equivalent Œµ-NFA using Thompson's construction.</p>
                    
                    <h5>Base Cases:</h5>
                    <ul>
                        <li><strong>‚àÖ:</strong> No accept state</li>
                        <li><strong>Œµ:</strong> Start state is also accept state</li>
                        <li><strong>a:</strong> Start state ‚Üí a ‚Üí Accept state</li>
                    </ul>

                    <h5>Inductive Cases:</h5>
                    <ul>
                        <li><strong>Union (R‚ÇÅ + R‚ÇÇ):</strong> Create new start state with Œµ-transitions to both R‚ÇÅ and R‚ÇÇ start states</li>
                        <li><strong>Concatenation (R‚ÇÅR‚ÇÇ):</strong> Connect accept states of R‚ÇÅ to start state of R‚ÇÇ with Œµ-transitions</li>
                        <li><strong>Kleene Star (R*):</strong> Add Œµ-transitions for loops and bypassing</li>
                    </ul>
                </div>
            </section>

            <section id="equivalence-regex-fa">
                <h2>7. Equivalence of Regular Expressions and Finite Automata</h2>
                
                <h3>The Fundamental Equivalence</h3>
                <div class="concept">
                    <h4>‚öñÔ∏è Two Ways to Describe the Same Languages</h4>
                    
                    <p><strong>Theorem:</strong> A language is regular if and only if it can be described by a regular expression if and only if it can be recognized by a finite automaton.</p>
                    
                    <p>This means:</p>
                    <ul>
                        <li>Every regular expression has an equivalent finite automaton</li>
                        <li>Every finite automaton has an equivalent regular expression</li>
                        <li>Regular expressions and finite automata define the same class of languages</li>
                    </ul>
                </div>

                <h3>Automaton to Regular Expression Conversion</h3>
                <div class="algorithm-steps">
                    <h4>üîÑ State Elimination Method</h4>
                    
                    <h5>Algorithm Overview:</h5>
                    <ol>
                        <li><strong>Prepare:</strong> Ensure single start state and single accept state</li>
                        <li><strong>Eliminate:</strong> Remove states one by one (except start and accept)</li>
                        <li><strong>Update:</strong> When removing a state, update transitions to preserve language</li>
                        <li><strong>Result:</strong> Final expression is the label on the transition from start to accept</li>
                    </ol>

                    <h5>State Elimination Rule:</h5>
                    <p>When eliminating state q with:</p>
                    <ul>
                        <li>Incoming transitions labeled R‚ÇÅ, R‚ÇÇ, ... from states p‚ÇÅ, p‚ÇÇ, ...</li>
                        <li>Outgoing transitions labeled S‚ÇÅ, S‚ÇÇ, ... to states r‚ÇÅ, r‚ÇÇ, ...</li>
                        <li>Self-loop labeled T</li>
                    </ul>
                    <p>Add direct transitions from each p·µ¢ to each r‚±º labeled: R·µ¢T*S‚±º</p>
                </div>

                <div class="example-detailed">
                    <h4>üîß Example: Converting Simple DFA to Regular Expression</h4>
                    
                    <h5>Original DFA (accepts strings with even number of 1s):</h5>
                    <div class="state-diagram">
                        q‚ÇÄ --0--> q‚ÇÄ
                        <br>
                        q‚ÇÄ --1--> q‚ÇÅ
                        <br>
                        q‚ÇÅ --0--> q‚ÇÅ
                        <br>
                        q‚ÇÅ --1--> q‚ÇÄ
                        <br><br>
                        Start: q‚ÇÄ, Accept: {q‚ÇÄ}
                    </div>

                    <h5>Conversion Process:</h5>
                    <ol>
                        <li><strong>Add new start and accept states:</strong> q_start ‚Üí q‚ÇÄ, q‚ÇÄ ‚Üí q_accept</li>
                        <li><strong>Eliminate q‚ÇÅ:</strong>
                            <ul>
                                <li>Path q‚ÇÄ ‚Üí q‚ÇÅ ‚Üí q‚ÇÄ: Label becomes 1¬∑0*¬∑1</li>
                                <li>Update transition q‚ÇÄ ‚Üí q‚ÇÄ: 0 + 10*1</li>
                            </ul>
                        </li>
                        <li><strong>Final expression:</strong> (0 + 10*1)*</li>
                    </ol>

                    <p><strong>Verification:</strong> This expression matches strings with even number of 1s!</p>
                </div>
            </section>

            <section id="ardens-method">
                <h2>8. Arden's Method - Converting NFA to Regular Expression</h2>
                
                <h3>Understanding Arden's Theorem</h3>
                <div class="mathematical-foundation">
                    <h4>üßÆ Arden's Theorem</h4>
                    
                    <p><strong>Theorem:</strong> If X = AX + B where A and B are regular expressions and Œµ ‚àâ L(A), then X = A*B.</p>
                    
                    <h5>What This Means:</h5>
                    <ul>
                        <li>X represents the set of strings that reach a particular state</li>
                        <li>AX represents strings that loop back to the same state</li>
                        <li>B represents strings that reach the state directly</li>
                        <li>The solution X = A*B gives us the regular expression</li>
                    </ul>

                    <h5>Application Strategy:</h5>
                    <ol>
                        <li>Write equations for each state based on incoming transitions</li>
                        <li>Solve the system of equations using substitution</li>
                        <li>Apply Arden's theorem to eliminate recursive definitions</li>
                        <li>The equation for accept states gives the final regular expression</li>
                    </ol>
                </div>

                <div class="example-detailed">
                    <h4>üîß Example: Arden's Method Application</h4>
                    
                    <h5>Given NFA:</h5>
                    <div class="state-diagram">
                        q‚ÇÄ --a--> q‚ÇÄ
                        <br>
                        q‚ÇÄ --b--> q‚ÇÅ
                        <br>
                        q‚ÇÅ --a--> q‚ÇÇ
                        <br>
                        q‚ÇÅ --b--> q‚ÇÅ
                        <br>
                        q‚ÇÇ --a--> q‚ÇÇ
                        <br>
                        q‚ÇÇ --b--> q‚ÇÅ
                        <br><br>
                        Start: q‚ÇÄ, Accept: {q‚ÇÇ}
                    </div>

                    <h5>Step 1: Write State Equations</h5>
                    <ul>
                        <li>q‚ÇÄ = Œµ + q‚ÇÄa (start state plus loops)</li>
                        <li>q‚ÇÅ = q‚ÇÄb + q‚ÇÅb + q‚ÇÇb</li>
                        <li>q‚ÇÇ = q‚ÇÅa + q‚ÇÇa</li>
                    </ul>

                    <h5>Step 2: Solve Using Arden's Theorem</h5>
                    <div class="algorithm-steps">
                        <ol>
                            <li><strong>From q‚ÇÄ = Œµ + q‚ÇÄa:</strong> q‚ÇÄ = a*</li>
                            <li><strong>Substitute into q‚ÇÅ equation:</strong> q‚ÇÅ = a*b + q‚ÇÅb + q‚ÇÇb</li>
                            <li><strong>From q‚ÇÇ = q‚ÇÅa + q‚ÇÇa:</strong> q‚ÇÇ = q‚ÇÅa*</li>
                            <li><strong>Substitute q‚ÇÇ into q‚ÇÅ:</strong> q‚ÇÅ = a*b + q‚ÇÅb + q‚ÇÅa*b</li>
                            <li><strong>Simplify:</strong> q‚ÇÅ = a*b + q‚ÇÅ(b + a*b) = a*b + q‚ÇÅb(Œµ + a*)</li>
                            <li><strong>Apply Arden's:</strong> q‚ÇÅ = (b(Œµ + a*))*a*b</li>
                            <li><strong>Final result:</strong> q‚ÇÇ = q‚ÇÅa* = (b(Œµ + a*))*a*ba*</li>
                        </ol>
                    </div>

                    <h5>Simplified Regular Expression:</h5>
                    <p>After algebraic simplification: <strong>(a + ba*b)*ba*</strong></p>
                </div>
            </section>

            <section id="conversion-methods">
                <h2>9. Conversion Methods Summary - The Complete Toolkit</h2>
                
                <div class="quick-reference">
                    <h4>üîÑ Conversion Methods Overview</h4>
                    
                    <h5>Between Automata Types:</h5>
                    <ul>
                        <li><strong>NDFA ‚Üí DFA:</strong> Subset construction algorithm</li>
                        <li><strong>Œµ-NFA ‚Üí NFA:</strong> Œµ-closure elimination</li>
                        <li><strong>NFA ‚Üí DFA:</strong> Subset construction (handles non-determinism)</li>
                    </ul>

                    <h5>Regular Expression ‚Üî Automata:</h5>
                    <ul>
                        <li><strong>RegEx ‚Üí Œµ-NFA:</strong> Thompson's construction</li>
                        <li><strong>DFA ‚Üí RegEx:</strong> State elimination method</li>
                        <li><strong>NFA ‚Üí RegEx:</strong> Arden's method or state elimination</li>
                    </ul>

                    <h5>When to Use Each Method:</h5>
                    <ul>
                        <li><strong>Design Phase:</strong> Use NDFA or RegEx (easier to design)</li>
                        <li><strong>Implementation:</strong> Convert to DFA (easier to implement)</li>
                        <li><strong>Analysis:</strong> Use RegEx (easier to analyze and modify)</li>
                        <li><strong>Optimization:</strong> Use DFA minimization techniques</li>
                    </ul>
                </div>

                <div class="exam-tip">
                    <strong>Exam Strategy:</strong> Practice all conversion methods thoroughly. Exam questions often ask you to convert between different representations. Start with the representation that's easiest for the given problem, then convert as needed. Remember that all these representations are equivalent - they describe the same class of regular languages.
                </div>
            </section>

            <section id="applications">
                <h2>10. Real-World Applications - Theory in Practice</h2>
                
                <div class="real-world-application">
                    <h4>üåç Finite Automata in Modern Technology</h4>
                    
                    <h5>Lexical Analysis in Compilers:</h5>
                    <ul>
                        <li><strong>Problem:</strong> Recognize tokens in source code (keywords, identifiers, numbers)</li>
                        <li><strong>Solution:</strong> DFA for each token type, combined into a single lexer</li>
                        <li><strong>Example:</strong> Recognizing integer literals: (0 + 1 + ... + 9)(0 + 1 + ... + 9)*</li>
                    </ul>

                    <h5>Text Processing and Search:</h5>
                    <ul>
                        <li><strong>grep command:</strong> Uses regular expressions for pattern matching</li>
                        <li><strong>Text editors:</strong> Find/replace functionality</li>
                        <li><strong>Web forms:</strong> Input validation (email, phone numbers)</li>
                    </ul>

                    <h5>Network Protocol Analysis:</h5>
                    <ul>
                        <li><strong>Packet filtering:</strong> Firewalls use automata to match packet patterns</li>
                        <li><strong>Intrusion detection:</strong> Recognize attack signatures</li>
                        <li><strong>Protocol verification:</strong> Ensure communication follows standards</li>
                    </ul>

                    <h5>Bioinformatics:</h5>
                    <ul>
                        <li><strong>DNA sequence analysis:</strong> Find gene patterns</li>
                        <li><strong>Protein folding:</strong> Recognize structural motifs</li>
                        <li><strong>Evolutionary analysis:</strong> Compare genetic sequences</li>
                    </ul>
                </div>
            </section>

            <section id="summary">
                <h2>11. Unit 1 Summary - Your Automata Toolkit</h2>
                
                <div class="quick-reference">
                    <h4>üéØ Key Concepts Mastered</h4>
                    
                    <h5>Automata Models:</h5>
                    <ul>
                        <li><strong>DFA:</strong> Deterministic, predictable, easy to implement</li>
                        <li><strong>NDFA:</strong> Non-deterministic, flexible design, multiple paths</li>
                        <li><strong>Œµ-NFA:</strong> Silent transitions, even more design flexibility</li>
                    </ul>

                    <h5>Regular Expressions:</h5>
                    <ul>
                        <li><strong>Syntax:</strong> Union (+), concatenation, Kleene star (*)</li>
                        <li><strong>Applications:</strong> Pattern matching, text processing</li>
                        <li><strong>Equivalence:</strong> Same power as finite automata</li>
                    </ul>

                    <h5>Conversion Techniques:</h5>
                    <ul>
                        <li><strong>Subset Construction:</strong> NDFA to DFA conversion</li>
                        <li><strong>Thompson's Construction:</strong> RegEx to Œµ-NFA</li>
                        <li><strong>State Elimination:</strong> Automata to RegEx</li>
                        <li><strong>Arden's Method:</strong> Systematic equation solving</li>
                    </ul>

                    <h5>Practical Skills:</h5>
                    <ul>
                        <li>Design automata for given language specifications</li>
                        <li>Convert between different representations</li>
                        <li>Trace automata execution on input strings</li>
                        <li>Write regular expressions for common patterns</li>
                    </ul>
                </div>

                <div class="progress-indicator">
                    üéì Unit 1 Complete! Next: Unit 2 - Machine Properties and Limitations
                </div>
            </section>
        </main>
    </div>
</body>
</html>
